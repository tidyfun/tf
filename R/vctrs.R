c_names <- function(funs) {
  fnames <- as.list(names(funs) %||% rep("", length(funs)))
  elnames <- map(funs, \(x) names(x) %||% rep("", length(x)))
  # always use argnames
  # argnames replace elementnames if elments have length 1
  # else paste with "."
  names <- map2(fnames, elnames, \(x, y) {
    if (nzchar(x, keepNA = TRUE)) return(y)
    if (all(nzchar(y, keepNA = TRUE)) || length(y) == 1) return(rep(x, length(y)))
    paste(x, y, sep = ".")
  }) |>
    unlist()
  if (all(nzchar(names, keepNA = TRUE))) NULL else names
}


#----------------- s3 generics for tfd casting -----------------#

#' vctrs methods for \code{tf} objects
#'
#' These functions are the extensions that allow \code{tf} vectors
#' to work with \code{vctrs}.
#'
#' @rdname vctrs
#' @family tidyfun vctrs
#' @import vctrs
#' @method vec_cast tfd_reg
#' @export
#' @export vec_cast.tfd_reg
#' @inheritParams vctrs::vec_cast
vec_cast.tfd_reg <- function(x, to, ...) UseMethod("vec_cast.tfd_reg")

#' @rdname vctrs
#' @family tidyfun vctrs
#' @method vec_cast tfd_irreg
#' @export
#' @export vec_cast.tfd_irreg
vec_cast.tfd_irreg <- function(x, to, ...) UseMethod("vec_cast.tfd_irreg")


#' @rdname vctrs
#' @family tidyfun vctrs
#' @method vec_cast.tfd_reg tfd_reg
#' @export
vec_cast.tfd_reg.tfd_reg <- function(x, to, ...) x

#' @rdname vctrs
#' @family tidyfun vctrs
#' @method vec_cast.tfd_reg tfd_irreg
#' @export
vec_cast.tfd_reg.tfd_irreg <- function(x, to, ...) {
  stop(
    "casting tfd_irreg to tfd_reg not possible -- use \n",
    "  # tfd(<some tfd_irreg>, arg = <some vector>) \n",
    "  to force irregular data onto a common grid. "
  )
}

#' @rdname vctrs
#' @family tidyfun vctrs
#' @method vec_cast.tfd_irreg tfd_reg
#' @export
vec_cast.tfd_irreg.tfd_reg <- function(x, to, ...) {

  args <- attr(x, "arg")
  cast_x <- tfd(map(vctrs::vec_data(x), \(x) data.frame(arg = args, value = x)))
  as.tfd_irreg.tfd_reg(cast_x)
}

#' @rdname vctrs
#' @family tidyfun vctrs
#' @method vec_cast.tfd_irreg tfd_irreg
#' @export
vec_cast.tfd_irreg.tfd_irreg <- function(x, to, ...) x



#----------------- s3 generics for tfd coercion -----------------#

#' coercion methods for tfd objects
#' @name vctrs
#' @family tidyfun vctrs
#' @method vec_ptype2 tfd_reg
#' @export
#' @export vec_ptype2.tfd_reg
#' @inheritParams vctrs::vec_ptype2
vec_ptype2.tfd_reg <- function(x, y, ...) UseMethod("vec_ptype2.tfd_reg")

#' @name vctrs
#' @family tidyfun vctrs
#' @method vec_ptype2.tfd_reg tfd_reg
#' @export
vec_ptype2.tfd_reg.tfd_reg <- function(x, y, ...) {
  vec_ptype2_tfd_tfd(x, y, ...)
}

#' @name vctrs
#' @family tidyfun vctrs
#' @method vec_ptype2.tfd_reg tfd_irreg
#' @export
vec_ptype2.tfd_reg.tfd_irreg <- function(x, y, ...) {
  vec_ptype2_tfd_tfd(x, y, ...)
}

#' @name vctrs
#' @family tidyfun vctrs
#' @method vec_ptype2 tfd_irreg
#' @export
#' @export vec_ptype2.tfd_irreg
#' @inheritParams vctrs::vec_ptype2
vec_ptype2.tfd_irreg <- function(x, y, ...) UseMethod("vec_ptype2.tfd_irreg")

#' @name vctrs
#' @family tidyfun vctrs
#' @method vec_ptype2.tfd_irreg tfd_reg
#' @export
vec_ptype2.tfd_irreg.tfd_reg <- function(x, y, ...) {
  vec_ptype2_tfd_tfd(x, y, ...)
}

#' @name vctrs
#' @family tidyfun vctrs
#' @method vec_ptype2.tfd_irreg tfd_irreg
#' @export
vec_ptype2.tfd_irreg.tfd_irreg <- function(x, y, ...) {
  vec_ptype2_tfd_tfd(x, y, ...)
}


#----------------- main function for coercion of tfd -----------------#

#' @name vctrs
#' @family tidyfun vctrs
#' @export
vec_ptype2_tfd_tfd <- function(x, y, ...) {
  funs <- list(x, y)
  compatible <- do.call(rbind, map(funs, \(x) compare_tf_attribs(funs[[1]], x)))

  stopifnot(all(compatible[, "domain"]))
  make_irreg <- rep(FALSE, length(funs))
  irreg <- map_lgl(funs, is_irreg)
  if (!any(irreg) && !all(compatible[, "arg"])) {
    warning("concatenating functions on different grids.")
    make_irreg <- rep(TRUE, length(funs))
  }
  if (any(irreg) && !all(irreg)) {
    warning("concatenating functions on different grids.")
    make_irreg[!irreg] <- TRUE
  }
  new_resolution <- NULL
  if (!all(compatible[, "resolution"])) {
    new_resolution <- tf_resolution(funs[[1]])
    warning(
      "inputs have different resolutions, result has ",
      "resolution =", new_resolution
    )
    make_irreg[!compatible[, "resolution"]] <- TRUE
  }
  if (any(make_irreg)) {
    funs <- map_at(funs, which(make_irreg), as.tfd_irreg)
  }
  if (!all(compatible[, "evaluator_name"])) {
    warning(
      "inputs have different evaluators, result has ",
      attr(funs[[1]], "evaluator_name")
    )
  }
  attr_ret <- attributes(funs[[1]])
  if (any(irreg | make_irreg)) {
    attr_ret$arg <- flatten(map(funs, tf_arg))
  }
  attr_ret$names <- {
    tmp <- unlist(flatten(map(
      funs,
      function(x) names(x) %||% rep("", length(x))
    )))
    if (all(nzchar(tmp, keepNA = TRUE))) NULL else tmp
  }
  ret <- flatten(funs)
  attributes(ret) <- attr_ret
  setNames(ret, c_names(funs))
}


#----------------- s3 generics for tfb casting -----------------#

#' @rdname vctrs
#' @family tidyfun vctrs
#' @import vctrs
#' @method vec_cast tfb_spline
#' @export
#' @export vec_cast.tfb_spline
#' @inheritParams vctrs::vec_cast
vec_cast.tfb_spline <- function(x, to, ...) UseMethod("vec_cast.tfb_spline")

#' @rdname vctrs
#' @family tidyfun vctrs
#' @method vec_cast tfb_fpc
#' @export
#' @export vec_cast.tfd_irreg
vec_cast.tfb_fpc <- function(x, to, ...) UseMethod("vec_cast.tfb_fpc")


#' @rdname vctrs
#' @family tidyfun vctrs
#' @method vec_cast.tfb_spline tfb_spline
#' @export
vec_cast.tfb_spline.tfb_spline <- function(x, to, ...) {
  attributes_to <- flatten(list(list(x),
                        arg = list(tf_arg(to)),
                        attr(to, "basis_args")))
  do.call(tfb, attributes_to)
}

#' @rdname vctrs
#' @family tidyfun vctrs
#' @method vec_cast.tfb_spline tfb_fpc
#' @export
vec_cast.tfb_spline.tfb_fpc <- function(x, to, ...) {
  stop("casting tfb_fpc to tfb_spline is not allowed")
}

#' @rdname vctrs
#' @family tidyfun vctrs
#' @method vec_cast.tfb_fpc tfb_spline
#' @export
vec_cast.tfb_fpc.tfb_spline <- function(x, to, ...) {
  stop("casting tfb_spline to tfb_fpc is not allowed")
}

#' @rdname vctrs
#' @family tidyfun vctrs
#' @method vec_cast.tfb_fpc tfb_fpc
#' @export
vec_cast.tfb_fpc.tfb_fpc <- function(x, to, ...) x


#----------------- s3 generics for tfb coercion -----------------#

#' @rdname vctrs
#' @family tidyfun vctrs
#' @method vec_ptype2 tfb_spline
#' @export
#' @param y Vectors to cast.
#' @export vec_ptype2.tfb_spline
#' @inheritParams vctrs::vec_ptype2
vec_ptype2.tfb_spline <- function(x, y, ...) UseMethod("vec_ptype2.tfb_spline")

#' @rdname vctrs
#' @family tidyfun vctrs
#' @method vec_ptype2.tfb_spline tfb_spline
#' @export
#' @inheritParams vctrs::vec_ptype2
vec_ptype2.tfb_spline.tfb_spline <- function(x, y, ...) {
  vec_ptype2_tfb_tfb(x, y, ...)
}

#' @rdname vctrs
#' @family tidyfun vctrs
#' @method vec_ptype2.tfb_spline tfb_fpc
#' @export
#' @inheritParams vctrs::vec_ptype2
vec_ptype2.tfb_spline.tfb_fpc <- function(x, y, ...) {
  stop("concatenating tfb_spline & tfb_fpc objects is not allowed")
}

#' @rdname vctrs
#' @family tidyfun vctrs
#' @method vec_ptype2 tfb_fpc
#' @export
#' @export vec_ptype2.tfb_fpc
#' @inheritParams vctrs::vec_ptype2
vec_ptype2.tfb_fpc <- function(x, y, ...) UseMethod("vec_ptype2.tfb_fpc")

#' @name vctrs
#' @family tidyfun vctrs
#' @method vec_ptype2.tfb_fpc tfb_spline
#' @export
#' @inheritParams vctrs::vec_ptype2
vec_ptype2.tfb_fpc.tfb_spline <- function(x, y, ...) {
  stop("concatenating tfb_spline & tfb_fpc objects is not allowed")
}


#' @name vctrs
#' @family tidyfun vctrs
#' @method vec_ptype2.tfb_fpc tfb_fpc
#' @export
#' @inheritParams vctrs::vec_ptype2
vec_ptype2.tfb_fpc.tfb_fpc <- function(x, y, ...) {
  vec_ptype2_tfb_tfb(x, y, ...)
}



#----------------- main function for coercion of tfb -----------------#

#' @name vctrs
#' @family tidyfun vctrs
#' @export
vec_ptype2_tfb_tfb <- function(x, y, ...) {
  funs <- list(x, y)
  compatible <- do.call(rbind,
                        map(funs, \(y) compare_tf_attribs(x, y)))
  stopifnot(all(compatible[, "domain"]))
  rebase <- which(!compatible[, "arg"] | !compatible[, "basis_matrix"])
  if (any(rebase)) {
      fun_names <- map(as.list(match.call())[-1], \(x) deparse(x)[1])
      warning(
        "using tf_rebase with basis_from = ", fun_names[1],
        " for incompatible inputs ", paste(fun_names[rebase], collapse = ","))
      funs <- map_at(.x = funs, .at = rebase,
                     .f = tf_rebase, basis_from = funs[[1]])
  }
  if (!all(compatible[, "resolution"])) {
    warning(
      "inputs have different resolutions, result has ",
      "resolution =", attr(funs[[1]], "resolution")
    )
  }
  attr_ret <- attributes(funs[[1]])
  attr_ret$names <- {
    tmp <- unlist(flatten(map(
      funs,
      function(x) names(x) %||% rep("", length(x))
    )))
    if (all(nzchar(tmp, keepNA = TRUE))) NULL else tmp
  }
  ret <- flatten(funs)
  attributes(ret) <- attr_ret
  setNames(ret, c_names(funs))
}
